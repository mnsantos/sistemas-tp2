Implementar un RWLock sin inanición es importantísimo para el buen desarrollo del juego aquí presente, más aun si se considera que podría ser jugado por una cantidad muy grande de jugadores. Varios ataques podrían no resultar como es esperado si hay ininición para los escritores.

Una implementación de un método de transición entre estados de lectura y escritura podría mejorar la protección y desarrollo del juego, visto y considerando que podría por ejemplo permitir más concurrencia en la función $ubicar$, donde por el simple hecho de que el último en ubicar sus barcos inicia el juego y modifica su estado no se permite la lectura en simultáneo de la variable $jugando$ para chequeo de errores. Lo mismo sucede en $tocar$ donde puede que finalice el juego.

Respecto al servidor, nuestra primera implementación resolvía las conexiones entrantes lanzando primero $n$ threads para cada jugador y el i-ésimo thread realizaba el accept del i-ésimo jugador. Resolvimos cambiar dicha implementacion para que un único thread se quede a la espera de nuevas conexiones y los nuevos threads de atención se lanzan al momento de realizarse el $connect$ de cada uno. De esta manera no se tiene desde el principio $n$ threads $inactivos$ bloqueados. Algo similar sucede con los controladores, más importante es aun dado que no tenemos la certeza de cuantos controladores se conectarán al juego.